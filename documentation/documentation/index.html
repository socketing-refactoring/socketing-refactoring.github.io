<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>문서화와 통합 테스트: Swagger, Spring Rest Docs | Socketing Reactoring Dev Log</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style" type="text/css" crossorigin>
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/assets/css/style.css?v=">
  </head>
  <body>
    <header class="page-header" role="banner">
      <h1 class="project-name"><a href="/" style="color: #fff">Socketing Reactoring Dev Log</a></h1>
      <h2 class="project-tagline">Socketing 프로젝트 리팩토링 과정을 기록합니다.</h2>
      <nav>
        <a class="btn" href="/">Home</a>
        <a class="btn" href="/tags/">Tags</a>
        <a class="btn" href="/categories/">Categories</a>
      </nav>
    </header>

    <main id="content" class="main-content" role="main">
      <article>
  <h1>문서화와 통합 테스트: Swagger, Spring Rest Docs</h1>
  <p>
    <small>
      📅 2025-04-13
       | 📂 카테고리: 
        
          <a href="/categories/documentation/">Documentation</a>
        
      
       | 🏷️ 태그: 
        
          <a href="/tags/java/">Java</a>, 
        
          <a href="/tags/gradle/">Gradle</a>, 
        
          <a href="/tags/collaboration/">Collaboration</a>, 
        
          <a href="/tags/git/">Git</a>, 
        
          <a href="/tags/test/">Test</a>, 
        
          <a href="/tags/msa/">MSA</a>
        
      
    </small>
  </p>

  <div class="post-content">
    <h2 id="도입-배경">도입 배경</h2>

<p>API 문서화 작업은 많은 개발자가 협업하게 되는 환경에서 필수적인 작업인 것 같습니다.
처음 개발을 배울 때는 API 설계를 할 때 엑셀 또는 노션을 이용하여 API 문서 작업을 하는 것이 전부였습니다.
그러다가 Postman이나 Swagger Open Api를 이용하여 API 문서을 생성함과 동시에 API 테스트 환경도 만들 수 있다는 것을 알게 되었습니다.</p>

<p>Swagger는 팀 프로젝트에서 Next.js 백엔드 API를 개발할 때 사용해본 경험이 있습니다. 그런데 Nest.js에서 작업할 때부터 느꼈던 두 가지 단점이 계속 마음에 걸렸습니다.</p>

<ol>
  <li>Swagger 문서에 Descrption, Example 등을 추가하기 위해 소스 코드에 긴 분량의 애노테이션을 사용해야 한다는 점</li>
  <li>Api 요청 및 응답 값이 변경되면 수작업으로 문서를 수정해야 해서 수고롭고 휴먼 폴트의 가능성이 있다는 점</li>
</ol>

<p>Spring Rest Docs를 이용하면 통합 테스트를 통해 실제 API를 100%로 반영한 API 문서를 자동 생성할 수 있고
이 문서를 Swagger 문서 스펙으로 변환하는 것도 가능하다는 것을 알게 됐습니다.<br />
그래서 이번 프로젝트에서는 Spring boot에 문서화 환경을 이 방법으로 직접 세팅해보았습니다.</p>

<h2 id="1-swagger-문서화-세팅">1. Swagger 문서화 세팅</h2>

<h3 id="swagger-문서-자동-생성">Swagger 문서 자동 생성</h3>
<p>다음과 같이 의존성을 추가해주고 Sprint boot를 실행한 뒤 <code class="language-plaintext highlighter-rouge">/swagger-ui/index.html</code>에 접속하면<br />
Controller 소스 코드에 작성한 API들을 바탕으로 자동 생성된 Swagger Api 문서를 확인할 수 있습니다.</p>

<ul>
  <li>Gradle 의존성 추가</li>
</ul>

<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// build.gradle.kts</span>

<span class="k">dependencies</span> <span class="o">{</span>
    <span class="n">implementation</span><span class="o">(</span><span class="s2">"org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.5"</span><span class="o">)</span>
    <span class="c1">// 생략</span>
<span class="o">}</span>

<span class="c1">// 생략</span>
</code></pre></div></div>

<h3 id="swagger-문서-설정">Swagger 문서 설정</h3>

<p>저는 프로젝트 상황에 맞게 <code class="language-plaintext highlighter-rouge">appication.yml</code>에서 몇 가지 설정을 커스텀해주었습니다.<br />
API 문서의 URI, API의 정렬 순서 등을 설정할 수 있습니다. 어떤 설정 속성들이 있는지는 다음 공식 문서에서 확인할 수 있습니다.</p>
<blockquote>
  <p>Spring Doc 공식 문서 <a href="https://springdoc.org/#properties">https://springdoc.org/#properties</a></p>
</blockquote>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># application.yml</span>

<span class="c1"># 생략</span>

<span class="na">springdoc</span><span class="pi">:</span>
  <span class="na">default-consumes-media-type</span><span class="pi">:</span> <span class="s2">"</span><span class="s">application/json"</span>
  <span class="na">default-produces-media-type</span><span class="pi">:</span> <span class="s2">"</span><span class="s">application/json"</span>
  <span class="na">show-actuator</span><span class="pi">:</span> <span class="kc">false</span>                  <span class="c1"># don't include auto generated actuator api</span>
  <span class="na">api-docs</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/api/v1/members/api/json"</span>   
  <span class="na">swagger-ui</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/api/v1/members/api/docs"</span>    <span class="c1"># default path: /swagger-ui/index.html</span>
    <span class="na">operations-sorter</span><span class="pi">:</span> <span class="s2">"</span><span class="s">alpha"</span>          <span class="c1"># Sort by paths alphanumerically</span>
    <span class="na">disable-swagger-default-url</span><span class="pi">:</span> <span class="kc">true</span>
    <span class="na">display-request-duration</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div></div>

<h3 id="마이크로-서비스-환경에서-swagger-설정-java-코드로-설정">마이크로 서비스 환경에서 Swagger 설정 (Java 코드로 설정)</h3>

<p>Java 코드로도 Swagger 설정을 커스텀할 수 있습니다.<br />
저는 마이크로 서비스 환경에 맞게 Swagger에서 보내는 요청이 마이크로 서비스 서버로 바로 가지 않고
Nginx와 Spring Gateway Server가 있는 서버를 통해 마이크로 서비스로 라우팅될 수 있도록 대상 서버를 다음과 같이 바꾸어주었습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.jeein.member.config</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">io.swagger.v3.oas.models.OpenAPI</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.swagger.v3.oas.models.servers.Server</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OpenApiConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">OpenAPI</span> <span class="nf">customOpenAPI</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Server</span> <span class="n">server</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Server</span><span class="o">();</span>
        <span class="n">server</span><span class="o">.</span><span class="na">setUrl</span><span class="o">(</span><span class="s">"https://api.socketing.jeein.xyz"</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">OpenAPI</span><span class="o">().</span><span class="na">servers</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">server</span><span class="o">));</span>
    
<span class="o">}</span>

</code></pre></div></div>

<p>이렇게 하면 다음과 같이 Api 요청을 보낼 서버가 변경됩니다. 
서버를 리스트로 추가할 수도 있어서 로컬용, 개발용, 운영용 서버 등 여러 서버를 등록할 수도 있습니다.</p>

<p><img src="/assets/images/swagger-server.png" alt="swagger-server" /></p>

<p>그리고 Spring Gateway Server에는 마이크로 서비스들의 Swagger 문서를 불러오기 위해 다음과 같이 설정해주었습니다. 
마이크로 서비스들의 Swagger 문서는 api-docs.path에 등록한 경로 (또는 default인 /v3/api-docs)에 위치해 있으니 그 경로를 이용하면 됩니다.<br />
저는 마이크로 서비스의 Swagger 문서를 요청할 때도 Spring Gateway Server의 라우팅을 통할 수 있도록 Spring Gateway Server의 url을 이용하였습니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># application.yml</span>

<span class="na">springdoc</span><span class="pi">:</span>
  <span class="na">swagger-ui</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">/api/docs</span>
    <span class="s">urls[0]</span><span class="err">:</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">auth-service</span>
      <span class="na">url</span><span class="pi">:</span> <span class="s">https://api.socketing.jeein.xyz/api/v1/auth/api/json</span>
    <span class="s">urls[1]</span><span class="err">:</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">member-service</span>
      <span class="na">url</span><span class="pi">:</span> <span class="s">https://api.socketing.jeein.xyz/api/v1/members/api/json</span>
    <span class="s">urls[2]</span><span class="err">:</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">event-service</span>
      <span class="na">url</span><span class="pi">:</span> <span class="s">https://api.socketing.jeein.xyz/api/v1/events/api/json</span>
    <span class="s">urls[3]</span><span class="err">:</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">order-service</span>
      <span class="na">url</span><span class="pi">:</span> <span class="s">https://api.socketing.jeein.xyz/api/v1/orders/api/json</span>
</code></pre></div></div>

<p>이렇게 하면 다음과 같이 Spring Gateway Server의 Swagger ui에서 마이크로 서비스들의 Swagger 문서를 한곳에 모아 볼 수 있습니다.</p>

<p><img src="/assets/images/swagger-source.png" alt="swagger-source" /></p>

<h3 id="애노테이션-방식과-직접-문서를-생성하는-방식">애노테이션 방식과 직접 문서를 생성하는 방식</h3>

<p>Swagger가 자동으로 문서를 생성해주기는 하지만 description이나 example 그리고 예외 응답들을 관리하려면 추가적인 작업이 필요합니다.
소스 코드에 애노테이션을 추가하거나
자동 생성 문서를 사용하는 대신 문서를 직접 생성할 수 있습니다.<br />
애노테이션을 쓰게 될 경우 소스 코드를 건들여야 돼서 거부감이 있을 수 있습니다. 
이에 API 문서 코드를 분리하기 위해 인터페이스에 문서화 작업을 진행하는 방법 등이 우회 방식으로 사용되는 것으로 보였습니다.
이는 Spring doc demo 리포지토리에서 예시를 확인할 수 있습니다.</p>

<blockquote>
  <p>Swagger doc demo repository <a href="https://github.com/springdoc/springdoc-openapi-demos/tree/master/demo-spring-boot-3-webmvc/src/main/java/org/springdoc/demo/app2/api">https://github.com/springdoc/springdoc-openapi-demos/tree/master/demo-spring-boot-3-webmvc/src/main/java/org/springdoc/demo/app2/api</a></p>
</blockquote>

<p>저는 애노테이션 방식은 Next.js 프로젝트에서 사용해보았기 때문에 이번에는 <code class="language-plaintext highlighter-rouge">yml</code>에 문서를 직접 작성하는 방식을 실험해봤습니다.</p>

<p>‘yml’ 작성 방법은 Swagger에서 제공해주는 에디터를 참고하면 좋습니다.</p>
<blockquote>
  <p>Swagger Editor <a href="https://editor.swagger.io/">https://editor.swagger.io/</a></p>
</blockquote>

<p>직접 작성한 파일은 <code class="language-plaintext highlighter-rouge">src/main/resources/static</code>에 위치시키고 <code class="language-plaintext highlighter-rouge">application.yml</code>에 다음 설정을 추가해주면 직접 작성한 문서를 ui로 확인할 수 있습니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># application.yml</span>

<span class="na">springdoc</span><span class="pi">:</span>
  <span class="na">swagger-ui</span><span class="pi">:</span>
    <span class="na">url</span><span class="pi">:</span> <span class="s">/{file name}.yml</span>    <span class="c1"># also can use json</span>
</code></pre></div></div>

<h2 id="2-spring-rest-docs">2. Spring Rest Docs</h2>

<p>이번에는 Spring Rest Docs로 문서를 생성하는 방법입니다.
Swagger 문서는 장점이 정말 많지만 자세한 설명을 추가하려고 하면 main 코드를 건들여야 되거나 문서를 직접 작성해야 한다는 점이 단점으로 다가옵니다.<br />
Spring Rest Docs의 경우 test 코드를 작성하고 나서 테스트에 성공하고 나면 자동으로 Http 요청과 응답 snippet을 생성할 수 있습니다.
그리고 Gradle에서 asciidocTask를 이용하면 adoc 포맷의 문서를 html로 변환할 수도 있습니다.</p>

<p>테스트와 문서 작업을 통합하는 이 방식은 문서의 신뢰성도 확보하고 api가 변경될 때마다 이를 문서에 자동 반영할 수 있으며 main 소스 코드에 문서화 코드를 개입시키지 않을 수도 있어서  장점이 많은 방식입니다.</p>

<h3 id="gradle-설정">Gradle 설정</h3>

<p>Spring Rest Docs를 사용하기 위한 Gradle 설정은 다음 공식 문서를 참고하였습니다.</p>
<blockquote>
  <p>Spring Rest Docs 공식 문서 <a href="https://docs.spring.io/spring-restdocs/docs/current/reference/htmlsingle/">https://docs.spring.io/spring-restdocs/docs/current/reference/htmlsingle/</a></p>
</blockquote>

<p>제가 작성한 Gradle 설정 파일은 다음과 같습니다. 스니펫 생성 경로와 html 문서 생성 경로를 명시적으로 지정해주었습니다.</p>

<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// build.gradle.kts</span>

<span class="kn">import</span> <span class="nn">org.asciidoctor.gradle.jvm.AsciidoctorTask</span>

<span class="n">plugins</span> <span class="o">{</span>
    <span class="n">id</span><span class="o">(</span><span class="s2">"org.asciidoctor.jvm.convert"</span><span class="o">)</span> <span class="n">version</span> <span class="s2">"4.0.4"</span>
    <span class="c1">// 생략</span>
<span class="o">}</span>

<span class="n">configurations</span> <span class="o">{</span>
    <span class="n">create</span><span class="o">(</span><span class="s2">"asciidoctorExt"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">dependencies</span> <span class="o">{</span>
    <span class="n">testImplementation</span><span class="o">(</span><span class="s2">"org.springframework.restdocs:spring-restdocs-mockmvc"</span><span class="o">))</span>
    <span class="n">add</span><span class="o">(</span><span class="s2">"asciidoctorExt"</span><span class="o">,</span> <span class="s2">"org.springframework.restdocs:spring-restdocs-asciidoctor"</span><span class="o">)</span>

    <span class="c1">// 생략 (Junit 의존성 등 필요)</span>
<span class="o">}</span>

<span class="n">val</span> <span class="n">snippetsDir</span> <span class="n">by</span> <span class="n">extra</span> <span class="o">{</span> <span class="n">file</span><span class="o">(</span><span class="s2">"build/generated-snippets"</span><span class="o">)</span> <span class="o">}</span>

<span class="c1">// 테스트를 실행하면 snippetsDir에 스니펫 생성</span>
<span class="n">tasks</span><span class="o">.</span><span class="na">test</span> <span class="o">{</span>
    <span class="n">useJUnitPlatform</span><span class="o">()</span>
    <span class="n">outputs</span><span class="o">.</span><span class="na">dir</span><span class="o">(</span><span class="n">snippetsDir</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// snippetDir에 있는 snippet과 adoc 문서를 바탕으로 outputDir에 html 문서 생성</span>
<span class="n">val</span> <span class="n">asciidoctorTask</span> <span class="o">=</span>
    <span class="n">tasks</span><span class="o">.</span><span class="na">named</span><span class="o">&lt;</span><span class="n">AsciidoctorTask</span><span class="o">&gt;(</span><span class="s2">"asciidoctor"</span><span class="o">).</span><span class="na">apply</span> <span class="o">{</span>
        <span class="n">configure</span> <span class="o">{</span>

            <span class="n">inputs</span><span class="o">.</span><span class="na">dir</span><span class="o">(</span><span class="n">snippetsDir</span><span class="o">)</span>
            <span class="n">configurations</span><span class="o">(</span><span class="s2">"asciidoctorExt"</span><span class="o">)</span>
            <span class="n">dependsOn</span><span class="o">(</span><span class="n">tasks</span><span class="o">.</span><span class="na">test</span><span class="o">)</span>

            <span class="n">sources</span><span class="o">(</span>
                <span class="n">delegateClosureOf</span><span class="o">&lt;</span><span class="n">PatternSet</span><span class="o">&gt;</span> <span class="o">{</span>
                    <span class="n">include</span><span class="o">(</span><span class="s2">"index.adoc"</span><span class="o">)</span>
                <span class="o">},</span>
            <span class="o">)</span>
            <span class="n">baseDirFollowsSourceFile</span><span class="o">()</span> <span class="c1">// required to include adoc into index.adoc</span>

            <span class="n">setOutputDir</span><span class="o">(</span><span class="n">layout</span><span class="o">.</span><span class="na">buildDirectory</span><span class="o">.</span><span class="na">dir</span><span class="o">(</span><span class="s2">"docs/asciidoc/member-service"</span><span class="o">))</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="c1">// html 문서를 jar의 정적 소스 경로에 추가</span>
<span class="n">tasks</span><span class="o">.</span><span class="na">named</span><span class="o">&lt;</span><span class="n">BootJar</span><span class="o">&gt;(</span><span class="s2">"bootJar"</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// need to import BootJar class</span>
    <span class="n">archiveFileName</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s2">"member-service.jar"</span><span class="o">)</span>
    <span class="n">dependsOn</span><span class="o">(</span><span class="n">asciidoctorTask</span><span class="o">)</span>

    <span class="n">from</span><span class="o">(</span><span class="n">asciidoctorTask</span><span class="o">.</span><span class="na">map</span> <span class="o">{</span> <span class="n">it</span><span class="o">.</span><span class="na">outputDir</span> <span class="o">})</span> <span class="o">{</span>
        <span class="n">into</span><span class="o">(</span><span class="s2">"static/docs"</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="adoc-파일-생성">adoc 파일 생성</h3>

<p>이 설정대로 문서를 생성하려면 <code class="language-plaintext highlighter-rouge">src/docs/asciidoc</code> 위치에 문서의 형태가 될 <code class="language-plaintext highlighter-rouge">index.adoc</code>을 작성해두어야 합니다.
저는 <code class="language-plaintext highlighter-rouge">index.adoc</code>가 너무 길어지는 것을 방지하기 위해 <code class="language-plaintext highlighter-rouge">index.adoc</code>에서 개별 <code class="language-plaintext highlighter-rouge">.adoc</code> 파일들을 include하는 방식을 선택했습니다. AsciidoctorTask가 include된 adoc을 정상적으로 처리할 수 있게 하려면 위 설정처럼 <code class="language-plaintext highlighter-rouge">baseDirFollowsSourceFile()</code>를 꼭 추가해주어야 합니다.<br />
<code class="language-plaintext highlighter-rouge">adoc</code>의 메타데이터로 toc(Table Of Content) 설정을 추가해주면 문서의 목차가 생겨서 편리합니다. 이외 adoc 문법은 공식 문서를 참고할 수 있습니다.</p>
<blockquote>
  <p>Asciidoc 공식 문서 <a href="https://docs.asciidoctor.org/">https://docs.asciidoctor.org/</a></p>
</blockquote>

<pre><code class="language-adoc">// src/docs/asciidoc/index.adoc

= API 문서
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 4
:sectlinks:

== 회원가입

=== HTTP 요청

회원가입 요청에 대한 설명입니다.

include::join-request.adoc[]

=== HTTP 성공 응답

회원가입 성공 시 반환되는 응답입니다.

include::join-response.adoc[]

// 생략
</code></pre>

<p>Request Header 같은 경우 테스트 클래스 파일에서 특별히 문서화 코드가 없으면 스니펫이 생성되지 않습니다. 이를 대비하여 스니펫을 include할 때 <code class="language-plaintext highlighter-rouge">[opts=optional]</code> 옵션을 추가해주면 스니펫이 없는 경우 자동으로 문서에서 제외할 수 있습니다.</p>

<pre><code class="language-adoc">// src/docs/asciidoc/join-request.adoc

HTTP Request
include::{snippets}/join/success/base/http-request.adoc[opts=optional]

Request Headers
include::{snippets}/join/success/base/request-headers.adoc[opts=optional]

// 생략
</code></pre>

<p>한편 <code class="language-plaintext highlighter-rouge">index.adoc</code>에서 다른 adoc를 include하는 대신 link할 수도 있습니다. 그렇게 하려면 각각의 adoc들도 html로 변환되어야 하며 <code class="language-plaintext highlighter-rouge">index.adoc</code>이 <code class="language-plaintext highlighter-rouge">index.html</code>로 변환될 때 adoc에 대한 참조가 html에 대한 참조로 변경될 수 있도록 해야 합니다. 이를 위해 AsciidoctorTask에 다음 설정을 추가해야 합니다.</p>

<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">attributes</span><span class="o">(</span>
    <span class="n">mapOf</span><span class="o">(</span>
        <span class="s2">"snippets"</span> <span class="n">to</span> <span class="n">snippetsDir</span><span class="o">,</span>
        <span class="s2">"outfilesuffix"</span> <span class="n">to</span> <span class="s2">".html"</span><span class="o">,</span>
        <span class="s2">"relfileprefix"</span> <span class="n">to</span> <span class="s2">""</span><span class="o">,</span>
        <span class="s2">"xrefstyle"</span> <span class="n">to</span> <span class="s2">"short"</span><span class="o">,</span>
    <span class="o">),</span>
<span class="o">)</span>
</code></pre></div></div>

<h3 id="테스트-코드-작성과-문서화">테스트 코드 작성과 문서화</h3>

<p>다음은 문서화를 위해 작성한 회원가입 통합 테스트 코드입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/test/java/com/jeein/member/docs/join/JoinSuccessTest.java</span>

<span class="c1">// 생략</span>

<span class="nd">@SpringBootTest</span>
<span class="nd">@ActiveProfiles</span><span class="o">(</span><span class="s">"test"</span><span class="o">)</span>
<span class="nd">@Transactional</span>
<span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"회원가입 성공 테스트"</span><span class="o">)</span>
<span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">RestDocumentationExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JoinSuccessTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">WebApplicationContext</span> <span class="n">context</span><span class="o">;</span>

    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">;</span>

    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">ObjectMapper</span> <span class="n">objectMapper</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mockMvc</span><span class="o">;</span>

    <span class="nd">@BeforeEach</span>
    <span class="kt">void</span> <span class="nf">setUp</span><span class="o">(</span>
            <span class="nc">WebApplicationContext</span> <span class="n">webApplicationContext</span><span class="o">,</span>
            <span class="nc">RestDocumentationContextProvider</span> <span class="n">restDocumentation</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">mockMvc</span> <span class="o">=</span>
                <span class="nc">MockMvcBuilders</span><span class="o">.</span><span class="na">webAppContextSetup</span><span class="o">(</span><span class="n">webApplicationContext</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">documentationConfiguration</span><span class="o">(</span><span class="n">restDocumentation</span><span class="o">))</span>
                        <span class="o">.</span><span class="na">defaultRequest</span><span class="o">(</span>
                                <span class="n">get</span><span class="o">(</span><span class="s">"/"</span><span class="o">).</span><span class="na">accept</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">)</span>
                                        <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">))</span>
                        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"회원가입 요청이 유효하고 이메일과 닉네임이 고유하면 회원가입이 성공한다."</span><span class="o">)</span>
    <span class="kt">void</span> <span class="nf">joinMember_success</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">JoinRequestDTO</span> <span class="n">request</span> <span class="o">=</span> <span class="nc">JoinRequestDTO</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"email@example.com"</span><span class="o">,</span> <span class="s">"이름"</span><span class="o">,</span> <span class="s">"닉네임"</span><span class="o">,</span> <span class="s">"password"</span><span class="o">);</span>

        <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">post</span><span class="o">(</span><span class="nc">ApiPath</span><span class="o">.</span><span class="na">MEMBER_JOIN</span><span class="o">).</span><span class="na">content</span><span class="o">(</span><span class="n">objectMapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">request</span><span class="o">)))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isCreated</span><span class="o">())</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.code"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="s">"0"</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.message"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="nc">ResponseMessage</span><span class="o">.</span><span class="na">JOIN_SUCCESS</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.errors"</span><span class="o">).</span><span class="na">doesNotExist</span><span class="o">())</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.data.id"</span><span class="o">).</span><span class="na">exists</span><span class="o">())</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.data.email"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="s">"email@example.com"</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.data.name"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="s">"이름"</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.data.nickname"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="s">"닉네임"</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">header</span><span class="o">().</span><span class="na">string</span><span class="o">(</span><span class="s">"Location"</span><span class="o">,</span> <span class="n">containsString</span><span class="o">(</span><span class="s">"api/v1/members/"</span><span class="o">)))</span>
                <span class="o">.</span><span class="na">andDo</span><span class="o">(</span>
                        <span class="n">doc</span><span class="o">(</span>
                                <span class="nc">DocumentIdentifier</span><span class="o">.</span><span class="na">JOIN_SUCCESS_BASE</span><span class="o">,</span>
                                <span class="nc">MemberSnippet</span><span class="o">.</span><span class="na">MEMBER_JOIN_REQUEST_FIELDS</span><span class="o">,</span>
                                <span class="n">responseHeaders</span><span class="o">(</span>
                                        <span class="n">headerWithName</span><span class="o">(</span><span class="nc">HttpHeaders</span><span class="o">.</span><span class="na">LOCATION</span><span class="o">)</span>
                                                <span class="o">.</span><span class="na">description</span><span class="o">(</span><span class="s">"생성된 리소스의 URI"</span><span class="o">)),</span>
                                <span class="nc">CommonSnippet</span><span class="o">.</span><span class="na">successResponseWithDataFields</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>작성 내용을 요약하면 다음과 같습니다.</p>

<ul>
  <li>테스트 관련
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@SpringBootTest</code>로 전체 스프링 컨텍스트를 로딩 (통합 테스트)</li>
      <li><code class="language-plaintext highlighter-rouge">@ActiveProfiles("test")</code>로 test 프로파일의 데이터베이스 설정 이용</li>
      <li><code class="language-plaintext highlighter-rouge">@Transactional</code> 적용으로 테스트 종료 시 insert한 데이터 롤백</li>
      <li><code class="language-plaintext highlighter-rouge">@DisplayName</code>으로 테스트 클래스 및 테스트 메서드에 이름 부여</li>
      <li><code class="language-plaintext highlighter-rouge">@BeforeEach</code>로 테스트 메서드 실행 전에 Mockmvc 생성, 공통 헤더 적용</li>
      <li>요청 객체를 ObjectMapper로 json화하여 클라이언트의 요청 mocking</li>
      <li><code class="language-plaintext highlighter-rouge">andExpect()</code>로 기대한 결과와 실제 결과가 같은지 확인</li>
    </ul>
  </li>
  <li>문서화 관련
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@ExtendWith(RestDocumentationExtension.class)</code>으로 문서화 기능 활성화</li>
      <li><code class="language-plaintext highlighter-rouge">@BeforeEach</code>로 테스트 메서드 실행 전에 Mockmvc에 문서화 설정 적용</li>
      <li><code class="language-plaintext highlighter-rouge">andDo()</code>에 <code class="language-plaintext highlighter-rouge">document()</code>로 문서에 추가할 내용 작성
        <ul>
          <li><code class="language-plaintext highlighter-rouge">document()</code>의 wrapper 함수인 <code class="language-plaintext highlighter-rouge">doc()</code>을 이용하여 요청, 응답 body의 json의 출력을 보기 좋게 만드는 설정 추가</li>
          <li>Request Field 및 Respons과 Field 스니펫, 스니펫 저장 장소는 별도 파일에서 상수 및 enum으로 관리</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>이렇게 하면 다음과 같이 <code class="language-plaintext highlighter-rouge">build.gradle.kts</code>에 설정한 스니펫 생성 경로에 스니펫이 생성됩니다.</p>

<p><img src="/assets/images/rest-snippet.png" alt="rest snippet" /></p>

<pre><code class="language-adoc">// build/generated-snippets/join/success/base/http-request.adoc

POST /api/v1/members/join HTTP/1.1
Content-Type: application/json
Accept: application/json
Content-Length: 116
Host: localhost:8080

{
  "email" : "email@example.com",
  "name" : "이름",
  "nickname" : "닉네임",
  "password" : "password"
}
</code></pre>

<p>여기까지 설정을 마치고 <code class="language-plaintext highlighter-rouge">./gradlew bootJar</code>를 실행하면 <code class="language-plaintext highlighter-rouge">/docs/index.html</code>에서 완성된 문서를 확인할 수 있습니다.</p>

<h2 id="3-github-publishing">3. Github publishing</h2>

<p>마이크로 서비스에 접속하지 않고도 문서를 확인하고 싶거나 이  문서를 중앙집중식으로 관리하고 싶다면 Gradle의 git publish 플러그인을 이용할 수 있습니다.</p>

<blockquote>
  <p>레퍼런스<br />
네이버 핵데이 행사 리포지토리 <a href="https://github.com/naver/hackday-conventions-java/blob/master/build.gradle">https://github.com/naver/hackday-conventions-java/blob/master/build.gradle</a></p>
</blockquote>

<p>저는 github organization에 jekyll blog를 위한 리포지토리를 만들어두었기 때문에 문서를 리포지토리의 docs 폴더로 push하는 태스크를 다음과 같이 생성하였습니다. 이때 주의해야 할 것은 gitPublish는 기본적으로 기존 리포지토리의 내용을 모두 clean하여 삭제해버린다는 것입니다. 이를 방지하기 위하여 <code class="language-plaintext highlighter-rouge">preserve</code> 설정을 추가해주어야 합니다.</p>

<p>다음은 제가 이용한 Gradle 설정입니다. 이렇게 설정을 하고 로컬 컴퓨터에 설정에 명시한 리포지토리에 접근할 수 있는 github personal access token이 등록되어 있다면 <code class="language-plaintext highlighter-rouge">./gradlew gitPublishPush</code> 명령어를 통해 문서를 이 리포지토리에 push할 수 있습니다.</p>

<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// build.gradle.kts</span>

<span class="n">plugin</span> <span class="o">{</span>
    <span class="n">id</span><span class="o">(</span><span class="s2">"org.ajoberstar.git-publish"</span><span class="o">)</span> <span class="n">version</span> <span class="s2">"4.2.0"</span>
<span class="o">}</span>

<span class="n">val</span> <span class="n">asciidoctorOutputDir</span> <span class="o">=</span> <span class="n">layout</span><span class="o">.</span><span class="na">buildDirectory</span><span class="o">.</span><span class="na">dir</span><span class="o">(</span><span class="s2">"docs/asciidoc/member-service"</span><span class="o">)</span>

<span class="c1">// Publishing Document</span>
<span class="n">tasks</span><span class="o">.</span><span class="na">named</span><span class="o">(</span><span class="s2">"gitPublishCopy"</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">dependsOn</span><span class="o">(</span><span class="s2">"asciidoctor"</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">gitPublish</span> <span class="o">{</span>
    <span class="n">repoUri</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s2">"git@github.com:socketing-refactoring/socketing-refactoring.github.io.git"</span><span class="o">)</span>
    <span class="n">branch</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s2">"gh-pages"</span><span class="o">)</span>
    <span class="n">contents</span> <span class="o">{</span>
        <span class="n">from</span><span class="o">(</span><span class="n">asciidoctorOutputDir</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">into</span><span class="o">(</span><span class="s2">"docs/member-service"</span><span class="o">)</span>
        <span class="o">}</span>

        <span class="n">preserve</span> <span class="o">{</span>
            <span class="n">include</span><span class="o">(</span><span class="s2">"**"</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">commitMessage</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s2">"Update Member Service API documentation"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// 생략</span>
</code></pre></div></div>

<p>이렇게 하면 이제 서버를 실행시키지 않아도 다음과 같이 공용 리포지토리의 경로를 통해 문서를 확인할 수 있습니다.</p>

<p><a href="https://socketing-refactoring.github.io/docs/member-service/">https://socketing-refactoring.github.io/docs/member-service/</a></p>

<h2 id="4-asciidoc-to-swagger">4. Asciidoc To Swagger</h2>

<p>Spring Rest Docs를 통해 실제 Api와 100% 호환되는 API 문서를 생성하였습니다. 그러나 asciidoc 문서는 Api 테스트가 어렵다는 점이 아쉽습니다.<br />
이에 Asciidoc을 Swagger 문서로 변환하는 플러그인을 적용해보려고 합니다.</p>
<blockquote>
  <p>레퍼런스<br />
카카오페이 기술 블로그 <a href="https://tech.kakaopay.com/post/openapi-documentation/">https://tech.kakaopay.com/post/openapi-documentation/</a><br />
Velog <a href="https://velog.io/@suhongkim98/spring-Rest-Docs-Swagger-UI%EB%A1%9C-MSA-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-API-%EB%AC%B8%EC%84%9C-%ED%86%B5%ED%95%A9-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0">ssongkim’s devlog</a></p>
</blockquote>

<h3 id="gradle-설정-1">Gradle 설정</h3>

<p>기존 설정에서 다음 설정을 추가합니다.</p>

<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// build.gradle.kts</span>

<span class="n">plugins</span> <span class="o">{</span>
    <span class="n">id</span><span class="o">(</span><span class="s2">"com.epages.restdocs-api-spec"</span><span class="o">)</span> <span class="n">version</span> <span class="s2">"0.18.4"</span>
    <span class="c1">// 생략</span>
<span class="o">}</span>

<span class="k">dependencies</span> <span class="o">{</span>
    <span class="n">testImplementation</span><span class="o">(</span><span class="s2">"com.epages:restdocs-api-spec-mockmvc:0.18.4"</span><span class="o">)</span>
    <span class="c1">// 생략</span>
<span class="o">}</span>

<span class="n">openapi3</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">setServer</span><span class="o">(</span><span class="s2">"https://api.socketing.jeein.xyz"</span><span class="o">)</span>
    <span class="n">title</span> <span class="o">=</span> <span class="s2">"My API"</span>
    <span class="n">description</span> <span class="o">=</span> <span class="s2">"My API description"</span>
    <span class="n">version</span> <span class="o">=</span> <span class="s2">"0.1.0"</span>
    <span class="n">format</span> <span class="o">=</span> <span class="s2">"yaml"</span> <span class="c1">// or json</span>
<span class="o">}</span>
</code></pre></div></div>

<p>여기서 주의할 점은 epage에서 제공하는 라이브러리의 버전입니다. 스프링 부트 3부터는 17 이상의 버전을 사용해야 <code class="language-plaintext highlighter-rouge">RequestParameterSnipp</code> NoClassDefFoundError 를 피할 수 있습니다.</p>

<blockquote>
  <p>epage restdocs 공식 문서 <a href="https://github.com/ePages-de/restdocs-api-spec">https://github.com/ePages-de/restdocs-api-spec</a></p>
</blockquote>

<p>그리고 이 라이브러리를 사용해보니 spring rest docs와 조금 차이가 나는 부분도 있는 것 같습니다. 예를 들어, 유효성 검사 테스트에서 어떤 파라미터에 null이 들어가는 경우를 테스트할 때 원래는 Snippet의 해당 필드 type이 STRING 이어도 테스트가 실패하지 않았었는데 epage의 rest docs의 경우 request field snippet의 타입과 요청 데이터의 타입이 일치하지 않는다는 이유로 테스트가 실패했습니다. 그래서 저는 실패 테스트의 경우에는 request field snippet 문서화를 하지 않는 것으로 오류를 해결했습니다.</p>

<h3 id="java-코드-수정">Java 코드 수정</h3>

<p>이제 테스트 코드에서 <code class="language-plaintext highlighter-rouge">andDo()</code> 안의 <code class="language-plaintext highlighter-rouge">document()</code>를 <code class="language-plaintext highlighter-rouge">org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document</code>에서 <code class="language-plaintext highlighter-rouge">com.epages.restdocs.apispec.MockMvcRestDocumentationWrapper.document</code>로 바꾸어주기만 하면 됩니다. document 이외에는 <code class="language-plaintext highlighter-rouge">org.springframework.restdocs.mockmvc.MockMvcRestDocumentation</code> 패키지의 클래스들을 그대로 이용하면 됩니다.</p>

<p>저는 <code class="language-plaintext highlighter-rouge">document()</code>를 감싸는 wrapper 함수를 사용하고 있었다보니 이 함수가 있는 클래스에서 import문 하나만 바꿔주니 테스트 코드를 수정할 필요 없이 바로 epage의 document를 적용할 수 있었습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">com</span><span class="o">.</span><span class="na">epages</span><span class="o">.</span><span class="na">restdocs</span><span class="o">.</span><span class="na">apispec</span><span class="o">.</span><span class="na">MockMvcRestDocumentationWrapper</span><span class="o">.</span><span class="na">document</span><span class="o">;</span>
<span class="c1">// 생략</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RestDocsUtil</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">RestDocumentationResultHandler</span> <span class="nf">doc</span><span class="o">(</span><span class="nc">String</span> <span class="n">identifier</span><span class="o">,</span> <span class="nc">Snippet</span><span class="o">...</span> <span class="n">snippets</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">document</span><span class="o">(</span>
                <span class="n">identifier</span><span class="o">,</span>
                <span class="n">preprocessRequest</span><span class="o">(</span><span class="n">prettyPrint</span><span class="o">()),</span>
                <span class="n">preprocessResponse</span><span class="o">(</span><span class="n">prettyPrint</span><span class="o">()),</span>
                <span class="n">snippets</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>이제 <code class="language-plaintext highlighter-rouge">./gradlew openapi3</code>를 실행하면 <code class="language-plaintext highlighter-rouge">build/api-spec</code> 위치에 <code class="language-plaintext highlighter-rouge">openapi3.yaml</code>이 생성됩니다. Swagger Editor를 통해 ui 버전을 확인해보면 다음과 같습니다. spring rest docs와 연동하니 테스트해본 예외 응답들을 자동으로 문서화할 수 있어서 편리한 것 같습니다.</p>

<p><img src="/assets/images/swagger-epage.png" alt="swagger-epage" /></p>

<p>Swagger 스펙의 문서가 만들어졌으니 이를 ui로 변환해서 볼 방법을 고민해야 합니다. 이에 대해서는 위 레퍼런스를 참고하면 좋을 것 같습니다. 저의 경우 Spring Gateway Server가 있는 서버가 지금 생성된 문서를 사용할 수 있도록 문서를 json 타입의 정적 리소스로 배포하면 될 것 같습니다.</p>

<h2 id="리뷰">리뷰</h2>

<p>Swagger와 Spring Rest Docs를 이용하여 문서화를 적용해보았습니다. 각각의 장점이 뚜렷하다보니 둘의 장점을 모두 취할 수 있는 방법을 선택하게 되었습니다.<br />
아쉬운 점이 있다면 점점 Gradle의 태스크가 늘어나고 있어서 빌드 시간이 길어지고 있습니다. 특히 문서화를 위한 테스트 코드가 통합 테스트이다보니 특히나 테스트 작업이 오래 걸립니다. 그나마 마이크로 서비스라서 빌드 시간이 이 정도였다는 생각에 마이크로 서비스 아키텍처의 장점을 느끼기도 하였습니다. 앞으로는 테스트와 빌드 작업 최적화 방법을 고민해보면 좋을 것 같습니다.</p>

  </div>
</article>

<hr>

<p><a href="/">← 돌아가기</a></p>


      <footer class="site-footer">
        <p>&copy; 2025 Socketing Reactoring Dev Log. Powered by <a href="https://jekyllrb.com" target="_blank">Jekyll</a>.</p>
      </footer>
    </main>
  </body>
</html>
